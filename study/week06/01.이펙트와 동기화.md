#이펙트와 동기화

## useEffect가 이벤트와 다른 점

렌더링 코드는 순수하게 렌더만 할뿐 다른 작업은 수행하지 않음.

이벤트 처리로만 충분하지 않음.

=> ueseffect 를 사용하면 렌더링 자체로 인해 발생하는 부작용을 지정할 수 있음.

반드시 effect 가 필요한것은 아님.

## effect 작성 방법

1. 선언

```jsx
import { useEffect } from "react";
```

코드 추가

```jsx
const Test = () => {
  useEffect(() => {

  })
  return ()
}
```

컴포넌트가 렌더링될때마다 화면을 업데이트 한 다음 내부 코드를 실행.

```jsx
function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  if (isPlaying) {
    ref.current.play(); // Calling these while rendering isn't allowed.
  } else {
    ref.current.pause(); // Also, this crashes.
  }

  return <video ref={ref} src={src} loop playsInline />;
}
```

이렇게 하면 ref를 못찾는다.
effect 로 감싸줘야 한다. (먼저 화면을 업데이트 하도록)

2. 종속성 지정
   매번 실행을 막기 위해선 종속성을 지정해서 변화에 대해 감지한다.

```jsx
useEffect(() => {
  if (isPlaying) {
    ref.current.play();
  } else {
    ref.current.pause();
  }
}, [isPlaying]);
```

3. 필요한 경우 정리
   다른 화면으로 갈때 마운트가 해제될되고, 다시 돌아올때 마운트 될때 해제되는것이 파괴전되지 않고 계속 쌓여서 return 처리를 해준다.

```jsx
useEffect(() => {
  const connection = createConnection();
  connection.connect();
  return () => {
    connection.disconnect();
  };
}, []);
```

## Remounting 후 작동하도록 내 Effect를 수정하는 방법

### 비 React 위젯 제어

```jsx
useEffect(() => {
  const map = mapRef.current;
  map.setZoomLevel(zoomLevel);
}, [zoomLevel]);
```

react 의 usestate를 사용하는 경우 정리가 필요하지 않는다.

```jsx
useEffect(() => {
  const dialog = dialogRef.current;
  dialog.showModal();
  return () => dialog.close();
}, []);
```

dialog의 내장된 showModal은 두번 호줄된다.

### 이벤트 구독

```jsx
useEffect(() => {
  function handleScroll(e) {
    console.log(window.scrollX, window.scrollY);
  }
  window.addEventListener("scroll", handleScroll);
  return () => window.removeEventListener("scroll", handleScroll);
}, []);
```

addEventListener호출 한 다음 removeEventListener를 지우는데
한번에 하나의 활성구독만 있게된다.

### 트리거 애니메이션

```jsx
useEffect(() => {
  const node = ref.current;
  node.style.opacity = 1; // Trigger the animation
  return () => {
    node.style.opacity = 0; // Reset to the initial value
  };
}, []);
```

무언가를 애니메이션화 하는 경우 초기값으로 재설정해야한다.
=> 이런경우는 잘없음.

### 데이터를 가져오는중?

```jsx
useEffect(() => {
  let ignore = false;

  async function startFetching() {
    const json = await fetchTodos(userId);
    if (!ignore) {
      setTodos(json);
    }
  }

  startFetching();

  return () => {
    ignore = true;
  };
}, [userId]);
```

cleanup은 더 이상 관련이 없는 가져오기가 애플리케이션에 계속 영향을 미치지 않도록 해야 합니다. => 무슨말일까..한번만 저장하게?

## 앱 초기화를 위해선 useEffect 를 안써도된다.

```jsx
if (typeof window !== "undefined") {
  // Check if we're running in the browser.
  checkAuthToken();
  loadDataFromLocalStorage();
}

function App() {
  // ...
}
```

## 제품 구매에서는 uesEffect 를 쓰지 않는다.

```jsx
useEffect(() => {
  // 🔴 Wrong: This Effect fires twice in development, exposing a problem in the code.
  fetch("/api/buy", { method: "POST" });
}, []);
```

이렇게 사용하면 다시 올때 구매가 된다.

구매는 event여야 해서 이벤트 핸들러로 만든다.

## 총집합

```jsx
function Playground() {
  const [text, setText] = useState("a");

  useEffect(() => {
    function onTimeout() {
      console.log("⏰ " + text);
    }

    console.log('🔵 Schedule "' + text + '" log');
    const timeoutId = setTimeout(onTimeout, 3000);

    return () => {
      console.log('🟡 Cancel "' + text + '" log'); 
      // 이전것들 정리한뒤 3초뒤 실행. 
      clearTimeout(timeoutId);
    };
  }, [text]);

  return (
    <>
      <label>
        What to log:{" "}
        <input value={text} onChange={(e) => setText(e.target.value)} />
      </label>
      <h1>{text}</h1>
    </>
  );
}
```
=> 디바운스? 

과제1 
https://codesandbox.io/s/sleepy-flower-0k0gk0?file=/MyInput.js

과제2
ref 안쓴 버전
https://codesandbox.io/s/objective-swanson-ddeb70?file=/MyInput.js

과제3
리턴으로 정리
https://codesandbox.io/s/loving-robinson-0hn27r?file=/Counter.js

과제4
리턴용 변수 선언
https://codesandbox.io/s/small-snowflake-z145fl?file=/App.js
