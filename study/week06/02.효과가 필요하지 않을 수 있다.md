#효과가 필요하지 않을 수 있다.

## 불필요한 useEffect를 제거하기

- 렌더링을 위해 데이터를 변환하는데 필요하지 않다. => 불필요한 렌더링 과정이 생긴다.
- 사용자 이벤트를 위해 필요하지 않다.

### 상태를 업데이트 할때 props나 state기반으로 업데이트

```jsx
useEffect(() => {
  setFullName(firstName + " " + lastName);
}, [firstName, lastName]);
``;
```

=>

```jsx
const fullName = firstName + " " + lastName;
```

이렇게 해야 계단식 업데이트를 피할 수 있고, 단순해지고, 오류 발생 가능성이 줄어든다.

### 비용이 많이 드는 계산 캐싱

```jsx
useEffect(() => {
  setVisibleTodos(getFilteredTodos(todos, filter));
}, [todos, filter]);
```

useEffect에 넣는건 좋지 않으니 뺀다면,

```jsx
const visibleTodos = getFilteredTodos(todos, filter);
```

이럴 경우 다시 계산하는 경우가 생긴다.

```jsx
const visibleTodos = useMemo(() => {
  // ✅ Does not re-run unless todos or filter change
  return getFilteredTodos(todos, filter);
}, [todos, filter]);
```

useMemo로 감싸면 괜춘

### props 변경시 모든 상태 재설정

```jsx
useEffect(() => {
  setComment("");
}, [userId]);
```

comment 값이 재 설정되지 않는다.

````jsx
  <Profile
      userId={userId}
      key={userId}
    />
    ```
````

key에 userId를 줘서 고유한 값으로 전달한다.

### props가 변경될때 일부 상태 조정

경웨 따라 props변경시 state의 일부를 재설정하거나 조정하고 싶은 경우

```jsx
function List({ items }) {
  const [isReverse, setIsReverse] = useState(false);
  const [selection, setSelection] = useState(null);

  // 🔴 Avoid: Adjusting state on prop change in an Effect
  useEffect(() => {
    setSelection(null);
  }, [items]);
  // ...
}
```

마찬가지로 불필요한 과정 (오래된 렌더링이 생긴다.)

```jsx
function List({ items }) {
  const [isReverse, setIsReverse] = useState(false);
  const [selection, setSelection] = useState(null);

  // Better: Adjust the state while rendering
  const [prevItems, setPrevItems] = useState(items);
  if (items !== prevItems) {
    setPrevItems(items);
    setSelection(null);
  }
  // ...
}
```

과정 생략하고 바로 렌더링 (오래된 렌더링은 건너뛴다)

```jsx
const selection = items.find((item) => item.id === selectedId) ?? null;
```

한줄로 압축가능

### 이벤트 핸들러간 로직 공유

```jsx
function ProductPage({ product, addToCart }) {
  // 🔴 Avoid: Event-specific logic inside an Effect
  useEffect(() => {
    if (product.isInCart) {
      showNotification(`Added ${product.name} to the shopping cart!`);
    }
  }, [product]);

  function handleBuyClick() {
    addToCart(product);
  }

  function handleCheckoutClick() {
    addToCart(product);
    navigateTo("/checkout");
  }
  // ...
}
```

장바구니 더할때, 페이지가 다시 로드 되는 시점에 알람이 뜰수있다.

```jsx
function ProductPage({ product, addToCart }) {
  // ✅ Good: Event-specific logic is called from event handlers
  function buyProduct() {
    addToCart(product);
    showNotification(`Added ${product.name} to the shopping cart!`);
  }

  function handleBuyClick() {
    buyProduct();
  }

  function handleCheckoutClick() {
    buyProduct();
    navigateTo("/checkout");
  }
  // ...
}
```

이벤트로 빼낸다.

### post 요청 보내기

```jsx
// ✅ Good: This logic should run because the component was displayed
useEffect(() => {
  post("/analytics/event", { eventName: "visit_form" });
}, []);

// 🔴 Avoid: Event-specific logic inside an Effect
const [jsonToSubmit, setJsonToSubmit] = useState(null);
useEffect(() => {
  if (jsonToSubmit !== null) {
    post("/api/register", jsonToSubmit);
  }
}, [jsonToSubmit]);
```

POST 요청은 Effect에 남아 있어야 합니다. 이는 분석 이벤트를 보내는 이유가 양식이 표시되었기 때문입니다 =>? 양식이 표시되었기 때문이다?

두번째 effect 는 state에 담지 않고 바로 보내야 하기 때문에

```jsx
function handleSubmit(e) {
  e.preventDefault();
  // ✅ Good: Event-specific logic is in the event handler
  post("/api/register", { firstName, lastName });
}
```

이벤트안에 넣는다.

### 계산 체인

다른 상태에 따라 상태를 조정하는 경우

상태가 연결되어있다면, useefecct 를 각자 쓴다면불필요요한 재렌더링이 발생한다.
새로운 요구사항이 있다면 각 상태의 데이터가 변경된다.

묶어서 이벤트에 넣어준다.

### 앱 초기화

앱로드랑 한번 실행되어야 한다면 최상단 app에 useEffect를 사용한다.

### 상태 변경에 대한 부모 구성 요소 알림

토글 에서 부모에게 구성요소의 상태를 넘기고 싶을땐 useEffect 보다 이벤트 핸들러에 넣어서 상태를 조절한다.

### 부모에게 데이터 전달 이라고 되어있지만 내용은 아님.

자식 요소가 Effects에서 부모 구성 요소의 상태를 업데이트하면 데이터 흐름을 추적하기가 매우 어려워집니다.
자식과 부모 모두 동일한 데이터가 필요하므로 부모 구성 요소가 해당 데이터를 가져와 대신 자식에게 전달하도록 합니다.

```jsx
function Parent() {
  const [data, setData] = useState(null);
  // ...
  return <Child onFetched={setData} />;
}

function Child({ onFetched }) {
  const data = useSomeAPI();
  // 🔴 Avoid: Passing data to the parent in an Effect
  useEffect(() => {
    if (data) {
      onFetched(data);
    }
  }, [onFetched, data]);
  // ...
}
```

자식에서 부모로 데이터를 넘길때 useEffect안에 넣으면안된다.

```jsx
function Parent() {
  const data = useSomeAPI();
  // ...
  // ✅ Good: Passing data down to the child
  return <Child data={data} />;
}

function Child({ data }) {
  // ...
}
```

=> 부모에서부터 데이터 정의하기.

### 외부 스토어 구독 이지만 useSyncExternalStore 에 대한 소개

browser 이벤트를 useEffect 안에 안쓰고, '구독'처리 할수 있는 함수
v18 버전에 사용가능한 것으로
v18을 쓸때 찾아보고

### 데이터를 가져 오는 중
검색 결과를 가져올때
```jsx
useEffect(() => {
  // 🔴 Avoid: Fetching without cleanup logic
  fetchResults(query, page).then((json) => {
    setResults(json);
  });
}, [query, page]);
```
검색조건이니 만큼 정리 함수를 추가해야된다. 

```jsx
function SearchResults({ query }) {
  const [results, setResults] = useState([]);
  const [page, setPage] = useState(1);
  useEffect(() => {
    let ignore = false;
    fetchResults(query, page).then(json => {
      if (!ignore) {
        setResults(json);
      }
    });
    return () => {
      ignore = true;
    };
  }, [query, page]);

  function handleNextPageClick() {
    setPage(page + 1);
  }
  // ...
}
```

### 데이터 가져오기 훅
```jsx
function SearchResults({ query }) {
  const [page, setPage] = useState(1);
  const params = new URLSearchParams({ query, page });
  const results = useData(`/api/search?${params}`);

  function handleNextPageClick() {
    setPage(page + 1);
  }
  // ...
}

function useData(url) {
  const [data, setData] = useState(null);
  useEffect(() => {
    let ignore = false;
    fetch(url)
      .then(response => response.json())
      .then(json => {
        if (!ignore) {
          setData(json);
        }
      });
    return () => {
      ignore = true;
    };
  }, [url]);
  return data;
}
```
이렇게 하면 오류 처리를 위한 논리르 추가하고, 콘텐츠가 로드되는지 여부를 추적할수있다고 한다. 
나중에 효율적인 데이터 가져오기 전략을 더 쉽게 채택할 수 있다.

과제1
https://codesandbox.io/s/busy-leaf-km8oqh

과제2:
https://codesandbox.io/s/cranky-cdn-6blh59?file=/App.js

과제3: 생각더해봐야됨
https://codesandbox.io/s/modest-phoebe-g5y7be?file=/EditContact.js

과제4:필요없는 useEffect 제거
https://codesandbox.io/s/magical-surf-d6c3q0?file=/App.js