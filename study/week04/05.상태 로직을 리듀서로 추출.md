# 상태 로직을 리듀서로 추출

상태 업데이트가 많은 구성 요소는 리듀서로 통합할 수 있다.

현재 상태 + 액션값을 전달 받아 새로운 상태를 반환함.

불변성을 지키면서 새로운 상태를 반환.

1단계 재정의

```
function handleAddTask(text) {
  setTasks([
    ...tasks,
    {
      id: nextId++,
      text: text,
      done: false,
    },
  ]);
}
function handleAddTask(text) {
  dispatch({
    type: 'added',
    id: nextId++,
    text: text,
  });
}

function handleChangeTask(task) {
  setTasks(
    tasks.map((t) => {
      if (t.id === task.id) {
        return task;
      } else {
        return t;
      }
    })
  );
}
function handleChangeTask(task) {
  dispatch({
    type: 'changed',
    task: task,
  });
}

function handleDeleteTask(taskId) {
  setTasks(tasks.filter((t) => t.id !== taskId));
}
function handleDeleteTask(taskId) {
  dispatch({
    type: 'deleted',
    id: taskId,
  });
}
```

dispatch는 state와 action으로 분리

2단계 리듀서 함수 작성

```
function tasksReducer(tasks, action) {
  if (action.type === 'added') {
    return [
      ...tasks,
      {
        id: action.id,
        text: action.text,
        done: false,
      },
    ];
  } else if (action.type === 'changed') {
    return tasks.map((t) => {
      if (t.id === action.task.id) {
        return action.task;
      } else {
        return t;
      }
    });
  } else if (action.type === 'deleted') {
    return tasks.filter((t) => t.id !== action.id);
  } else {
    throw Error('Unknown action: ' + action.type);
  }
}
```

if 말고 switch로 작성해야 가독이더 좋다

```
function tasksReducer(tasks, action) {
  switch (action.type) {
    case 'added': {
      return [
        ...tasks,
        {
          id: action.id,
          text: action.text,
          done: false,
        },
      ];
    }
    case 'changed': {
      return tasks.map((t) => {
        if (t.id === action.task.id) {
          return action.task;
        } else {
          return t;
        }
      });
    }
    case 'deleted': {
      return tasks.filter((t) => t.id !== action.id);
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}
```

useState vs useReducer

- 코드 크기
  일반적으로 usestate가 더 적지만, 비슷한 방식으로 상태 수정할 경우 useReducer가 나을 수 있다.
- 가독성
  usestate가 낫다.
- 디버깅
  usestate가 더 어렵다.
- 테스트
  useReducer는 컴포넌트에 의존하지 않는다? => ui에 의존하지 않는다인듯

리듀서 잘 작성하기
순수해야 한다 - 렌더링 중에 실행이된다.
데이터가 여러번 변경되도 하나의 작업으로 확인할 수 있어야 한다. ?

immer 로 작성할때

```
useReducer 를
 const [tasks, dispatch] = useImmerReducer(tasksReducer, initialTasks);
 로 변경

 reducer 함수는 받은 상태 그대로 
 function tasksReducer(draft, action) {
  switch (action.type) {
    case 'added': {
      draft.push({
        id: action.id,
        text: action.text,
        done: false,
      });
      break;
    }
    case 'changed': {
      const index = draft.findIndex((t) => t.id === action.task.id);
      draft[index] = action.task;
      break;
    }
    case 'deleted': {
      return draft.filter((t) => t.id !== action.id);
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}
```

과제1 : 디스패치로 전달
https://codesandbox.io/s/little-mountain-963mh8?file=/ContactList.js

과제2:
https://codesandbox.io/s/friendly-cray-kfum6v?file=/Chat.js

과제3: 
https://codesandbox.io/s/v9z8jg?file=/messengerReducer.js:432-440&utm_medium=sandpack

과제4:
https://codesandbox.io/s/frosty-shirley-ddsc9t?file=/MyReact.js