### 순수 컴포넌트 유지

---

**순수함수**

다른 데이터에 영향을 주지 않고, 동일한 입력값이 주어질 때, 항상 동일한 결과를 반환하는 함수

```
// 순수 함수
const pure = (number) => {
  return 2 * number;
}

// 순수하지 않은 함수 (a라는 변수가 바뀌면 값이 달라진다.)
const a = 2;
const pure = (number) => {
  return 2 * number + a
}
```

우리가 작성하는 모든 컴포넌트는 순수 함수이어야 한다.

```
// 순수하지 않은 함수
let guest = 0;

const Cup = () => {
  guest = guest + 1;
  return <h2>{guest}</h2>;
}

/** 메인 컴포넌트 */
const TeaSet = () => {
  return (
    <>
      <Cup /> // 2
      <Cup /> // 4
      <Cup /> // 6
    </>
  );
}
```

위 예제를 수정해보면,

```
// 같은 props를 넘겨주면 항상 동일한 값을 반환
const Cup = ({ guest }) => {
  return <h2>{guest}</h2>;
}

const TeaSet = () => {
  return (
    <>
      <Cup guest={1} /> // 1
      <Cup guest={2} /> // 2
      <Cup guest={1} /> // 1
    </>
  );
}
```

<br />

### Local Mutation, 컴포넌트의 작은 비밀 쉿 🤫

---

위에서 잘못된 예를 살펴봤는데, 컴포넌트가 렌더링하는 동안 기존에 있던 변수를 변경하는 것을 `mutation`라고 부르기도 합니다.

```
const Cup = ({ guest }) => {
  return <h2>Tea cup for guest #{guest}</h2>;
}

const TeaGathering = () => {
  let cups = [];

  for (let i = 1; i <= 12; i++) {
    cups.push(<Cup key={i} guest={i} />);
  }
  return cups;
}
```

위처럼 컴포넌트 내부에서 변경되는 값들은 괜찮다.

---

함수형 프로그래밍은 순수성에 의존하지만 언젠가는 어딘가에서 무언가를 변경해야 하는데, 이것이 바로 프로그래밍의 핵심이다. 화면 업데이트, 애니메이션 시작, 데이터 변경 등의 변경 사항이 발생하는데, 이는 이벤트 핸들러를 통해 구현하면 괜찮다.

React에서 사이드 이펙트는 보통 이벤트 핸들러 안에 속한다. 이벤트 핸들러는 사용자가 어떤 액션을 수행할 때(예를 들어 버튼을 클릭할 때) React가 실행하는 함수입니다. `ex: onClick`

\*\* 이벤트 핸들러는 렌더링 중에는 실행되지 않기 때문에 순수할 필요가 없다.

---

순수 함수를 작성하려면 약간의 습관과 훈련이 필요합니다. 하지만 놀라운 기회가 열리기도 합니다:

컴포넌트를 다른 환경(예: 서버)에서 실행할 수 있습니다! 동일한 입력에 대해 동일한 결과를 반환하므로 하나의 컴포넌트로 많은 사용자 요청을 처리할 수 있습니다.

입력이 변경되지 않은 컴포넌트는 굳이 또 렌더링을 진행할 필요가 없다. (결과물도 동일하기 때문) 순수 함수는 항상 동일한 결과를 반환하므로 캐싱해도 안전하고, 이를 통해 렌더링 최적화를 노릴 수 있다.

---

### 요약

모든 컴포넌트는 순수해야 한다. (외부 데이터에 영향 X)

React에서 무언가를 변경하고 싶다면, 이벤트 핸들러를 활용해야 한다.

end.
